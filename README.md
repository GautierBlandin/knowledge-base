# Knowledge Base
I created this as a summary of all the self-learning I'm doing in order to provide recruiters or other CS students with an overview of my areas of competence and also as a To-Do list that gives me an clear view of the concepts or skills I plan to learn in the near future.

Every item in the list links to the resources I used to understand it, and most of them also link to the notes and flashcards that I wrote for the item. If applicable, my implementations or related projects are linked too. ~items~ styled with strikethrough are items that I do not know yet but plan to learn.

# Overview

### Computer Science

<details>
  <summary>Programming Principles</summary>

  <ul>
    <li><a href="#solid"> SOLID Principles</a></li>
    <li><a href="#dry"> DRY / AHA</a></li>
    <li><a href="#desgin_patterns"> Design Patterns</a></li>
    <li><a href="#twelve_factor"> Twelve Factor App</a></li>
  </ul>

</details>

<details>
  <summary>Programming Techniques</summary>
  
  <ul>
    <li><a href"#memoization"> Memoization</a></li>
    <li><a href"#fluent_interface"> Fluent interfaces</a></li>
  </ul>

</details>

<details>
  <summary>Time & Space Complexities</summary>
  
  <ul>
    <li><a href""> Big O</a></li>
    <li><a href""> Amortized cost</a></li>
  </ul>
  
</details>

<details>
  <summary>Datastructures</summary>
  
  <ul>
    <li><a href""> Arrays</a></li>
    <li><a href""> Linked Lists</a></li>
    <li><a href""> Stacks and Queues</a></li>
    <li><a href""> Binary Trees</a></li>
    <li><a href""> Hash Tables</a></li>
    <li><a href""> Heaps</a></li>
  </ul>

</details>

<details>
  <summary>Algorithms</summary>
  
  <ul>
    <li><a href="">Binary Search </a></li>
    <li><a href="">Knuth Shuffle </a></li>
    <li><a href="">Selection Sort </a></li>
    <li><a href="">Insertion Sort </a></li>
    <li><a href="">Merge Sort </a></li>
    <li><a href="">Quick Sort </a></li>
  </ul>
  
</details>

<details>
  <summary>Graph Theory</summary>
  
  <ul>
    <li><a href="">General Concepts </a></li>
    <li><a href="">Breadth-first search </a></li>
    <li><a href="">Depth-first search </a></li>
  </ul>
  
</details>

<details>
  <summary>Dynamic programming</summary>
  
  <ul>
    <li><a href="">Optimal sub-structure </a></li>
    <li><a href="">Overlapping sub-problems </a></li>
  </ul>
  
</details>

### Mathematics
  
  * ~Probabilities & Statistics~
  * ~Fourier Transform~
  * ~Geometry~

### Web Standards
  
  * HTTP
  * OAuth 2.0
 
### Front-end development
  
  * Design principles
  * HTML
  * CSS
  * React
  * Next

### Back-end development
  
  * Express
  * Nest
  * TypeORM

### DevOps

  * CI/CD
  * Docker
  * Ansible

### Programming languages
  
<details>
  <summary>Javascript</summary>
  
  * Arrays
  * Strings
  * Objects
  * LocalStorage
  * Optional Chaining
  * Classes
  
</details>

<details>
  <summary>Typescript</summary>
  
  * Type annotations
  * Interfaces inheritance
  
</details>

<details>
  <summary>Python</summary>
  
  * Iterables
  * Generator expressions
  * Lists
  * Strings
  * Type hinting
  * Classes
  
</details>

## Markup Languages

  * YAML
  * JSON
  * LaTeX
  * PlantUML

--- 

# Details

<h4 id="solid"> SOLID Principles </h4>

- <a href="https://www.remnote.com/a/solid-design-principles/61e68e64849524001676e093"> Flashcards & Notes </a>
- [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single-responsibility_principle)
- [Open-Closed Principle](https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle)
- [Liskov Substitution Principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
- [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
- [Dependency Inversion Principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle)

<h4 id="dry"> DRY / AHA </h4>

- [Don't Repeat Yourself, but Avoid Hasty Abstractions](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)

<h4 id="design_patterns"> Design Patterns </h4>

- [Original GoF book](https://en.wikipedia.org/wiki/Design_Patterns)
- [Modern approach : refactoring.guru](https://refactoring.guru/design-patterns)
- Flashcards  & Notes :
  - [Introduction & key concepts](https://www.remnote.com/a/introduction-key-concepts-and-definitions/61a5530bb61d3100160b9c78)
  - [Creational Patterns](https://www.remnote.com/a/creational-patterns/61e697d1178e620016e1d3bb)
  - [Structural Patterns](https://www.remnote.com/a/structural-patterns/61a5530bffeb1400164cb357)
  - [Behavioral Patterns](https://www.remnote.com/a/behavioral-patterns/61e6947f4a52720016f389f7)

<h4 id="twelve_factors"> <a href="https://12factor.net/"> Twelve-Factor App </a></h4>

<h4 id="memoization"> Memoization </h4>

- [Flashcard](https://www.remnote.com/a/memoization/61e69bb6849524001676e1c9)
- [Wikipedia](https://en.wikipedia.org/wiki/Memoization)

<h4 id="fluent_interface"><a href="https://en.wikipedia.org/wiki/Fluent_interface"> Fluent Interface </a></h4>

<h4 id="time_space_complexity"> Times & Space Complexity </h4>

- [Flashcards & Notes](https://www.remnote.com/a/time-space-complexity/61e69f27849524001676e1de)
- [Big O](https://en.wikipedia.org/wiki/Big_O_notation)
- Amortized Analysis :
  - [Coursera (free)](https://www.coursera.org/learn/data-structures/lecture/hzlEI/amortized-analysis-aggregate-method)
  - Wiki : https://en.wikipedia.org/wiki/Amortized_analysis
